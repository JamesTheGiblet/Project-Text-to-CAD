<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text to CAD Generator - Iron Arm Foundation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            min-height: 100vh;
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
            height: fit-content;
        }

        .header {
            text-align: center;
            margin-bottom: 25px;
        }

        .header h1 {
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 2.2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .header .subtitle {
            color: #666;
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .phase-indicator {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
            display: inline-block;
            margin: 10px 0;
        }

        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #444;
        }

        textarea {
            width: 100%;
            min-height: 120px;
            padding: 15px;
            border: 2px solid #e1e1e1;
            border-radius: 10px;
            font-size: 14px;
            resize: vertical;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin: 20px 0;
        }

        button {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #f8f9fa;
            color: #333;
            border: 2px solid #e9ecef;
        }

        .btn-secondary:hover {
            background: #e9ecef;
            transform: translateY(-1px);
        }

        .btn-success {
            background: linear-gradient(135deg, #51cf66, #40c057);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(64, 192, 87, 0.4);
        }

        .blueprint-section {
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }

        .blueprint-section h3 {
            color: #667eea;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .blueprint-content {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e1e1e1;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }

        .viewer-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
            height: fit-content;
        }

        #viewer {
            width: 100%;
            height: 500px;
            border-radius: 10px;
            overflow: hidden;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border: 2px solid #e1e1e1;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 18px;
            position: relative;
        }

        .controls {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .controls h4 {
            margin-bottom: 10px;
            color: #444;
        }

        .controls ul {
            list-style: none;
            font-size: 12px;
            color: #666;
        }

        .controls li {
            margin: 3px 0;
        }

        .status {
            margin: 15px 0;
            padding: 12px;
            border-radius: 8px;
            font-weight: 500;
            display: none;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.info {
            background: #cce7ff;
            color: #004085;
            border: 1px solid #b3d7ff;
        }

        .quick-examples {
            margin: 20px 0;
        }

        .quick-examples h4 {
            margin-bottom: 10px;
            color: #444;
        }

        .example-btn {
            display: block;
            width: 100%;
            padding: 8px 12px;
            margin: 5px 0;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            text-align: left;
            transition: all 0.2s ease;
        }

        .example-btn:hover {
            background: #e9ecef;
            transform: translateX(5px);
        }

        .iron-arm-components {
            margin: 20px 0;
            padding: 15px;
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
            border-radius: 10px;
            color: #333;
        }

        .iron-arm-components h4 {
            margin-bottom: 10px;
            color: #d63384;
        }

        .component-btn {
            display: block;
            width: 100%;
            padding: 10px;
            margin: 8px 0;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.3s ease;
            color: #333;
        }

        .component-btn:hover {
            background: white;
            transform: scale(1.02);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        @media (max-width: 1024px) {
            .container {
                grid-template-columns: 1fr;
                gap: 15px;
            }
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="control-panel">
            <div class="header">
                <h1>üõ†Ô∏è Text to CAD Generator</h1>
                <p class="subtitle">Iron Arm Exoskeleton Foundation Tool</p>
                <div class="phase-indicator">üéØ Phase 0 - Weeks 1-2</div>
            </div>

            <div class="input-group">
                <label for="description">Describe your 3D object:</label>
                <textarea id="description" placeholder="Create a blue cube with width 2, height 1.5, and depth 1&#10;&#10;Or try one of the Iron Arm components below..."></textarea>
            </div>

            <div class="button-group">
                <button class="btn-primary" onclick="generateBlueprint()">üìã Generate Blueprint</button>
                <button class="btn-secondary" onclick="clearAll()">üóëÔ∏è Clear</button>
            </div>

            <div class="status" id="status"></div>

            <div class="blueprint-section" id="blueprintSection" style="display: none;">
                <h3>üìê Technical Blueprint</h3>
                <div class="blueprint-content" id="blueprintContent"></div>
                <div class="button-group" style="margin-top: 15px;">
                    <button class="btn-success" onclick="create3DModel()">üéØ Create 3D Model</button>
                    <button class="btn-secondary" onclick="editBlueprint()">‚úèÔ∏è Edit Blueprint</button>
                </div>
            </div>

            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>Processing your design...</p>
            </div>

            <div class="iron-arm-components">
                <h4>ü¶æ Iron Arm Components (Week 1-2 Priority)</h4>
                <button class="component-btn" onclick="loadComponent('upperArmCuff')">
                    1. Upper Arm Cuff Bracket
                </button>
                <button class="component-btn" onclick="loadComponent('elbowJoint')">
                    2. Elbow Joint Housing
                </button>
                <button class="component-btn" onclick="loadComponent('motorMount')">
                    3. Motor Mount Bracket
                </button>
                <button class="component-btn" onclick="loadComponent('controlBox')">
                    4. Control Electronics Box
                </button>
                <button class="component-btn" onclick="loadComponent('cableManagement')">
                    5. Cable Management System
                </button>
            </div>

            <div class="quick-examples">
                <h4>üí° Quick Examples</h4>
                <button class="example-btn" onclick="loadExample('cube')">
                    Create a red cube with size 2
                </button>
                <button class="example-btn" onclick="loadExample('sphere')">
                    Make a blue sphere with radius 1.5
                </button>
                <button class="example-btn" onclick="loadExample('cylinder')">
                    Create a green cylinder with radius 1 and height 3
                </button>
                <button class="example-btn" onclick="loadExample('complex')">
                    Create a gray box with width 4, height 2, depth 1. Add a red sphere with radius 0.5 on top.
                </button>
            </div>
        </div>

        <div class="viewer-panel">
            <div id="viewer">
                <div>üé® 3D Viewer Ready<br><small>Generate a blueprint to see your creation</small></div>
            </div>

            <div class="controls">
                <h4>üéÆ Camera Controls</h4>
                <ul>
                    <li>üñ±Ô∏è Left Click + Drag: Rotate view</li>
                    <li>üé° Mouse Wheel: Zoom in/out</li>
                    <li>üñ±Ô∏è Right Click + Drag: Pan camera</li>
                    <li>üíæ Export STL when model is ready</li>
                </ul>
            </div>

            <div class="button-group">
                <button class="btn-success" onclick="exportSTL()" id="exportBtn" disabled>üì• Export STL</button>
                <button class="btn-secondary" onclick="resetView()">üîÑ Reset View</button>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let currentModel = null;
        let currentBlueprint = null;
        let isViewerInitialized = false;

        // Color mapping
        const colorMap = {
            red: 0xff0000, blue: 0x0000ff, green: 0x00ff00, yellow: 0xffff00,
            purple: 0x800080, orange: 0xffa500, pink: 0xffc0cb, cyan: 0x00ffff,
            white: 0xffffff, black: 0x000000, gray: 0x808080, grey: 0x808080,
            silver: 0xc0c0c0
        };

        // Iron Arm component templates
        const ironArmComponents = {
            upperArmCuff: `Create upper arm cuff bracket:
- Main body: gray box with width 12, height 4, depth 2.5
- Servo attachment flange: rectangle with width 6, height 2, thickness 0.8
- Padding channels: 2 grooves with width 1, depth 0.5 for foam
- Velcro mounting tabs: 4 rectangles with width 2, height 1, thickness 0.3`,

            elbowJoint: `Make precision elbow joint housing:
- Main housing: black cylinder with radius 3.5 and height 2.8
- Bearing races: 2 silver rings with outer radius 3.2, inner radius 2.8  
- Cable routing channels: 4 grooves with width 0.8, depth 0.5
- Mounting boss: cylinder with radius 1.5 and height 1.2`,

            motorMount: `Generate servo motor mounting system:
- Base plate: gray rectangle with width 4.5, height 6, thickness 1.2
- Motor cavity: rectangular cutout with width 2, height 4, depth 2.5
- Screw bosses: 4 cylinders with radius 0.3 and height 0.8
- Cable management clips: 2 hooks with radius 0.5`,

            controlBox: `Create control system enclosure:
- Main body: blue box with width 8, height 5, depth 3
- Lid: gray plate with width 8.2, height 5.2, thickness 0.5
- Button cutouts: 2 cylinders with radius 0.8 and depth 1
- LED windows: 3 cylinders with radius 0.3 and depth 0.2
- Ventilation slots: 6 rectangles with width 3, height 0.3`,

            cableManagement: `Design cable routing components:
- Cable guide: gray cylinder with radius 1, height 2, wall thickness 0.3
- Strain relief: cone with base radius 1.2, tip radius 0.4, height 1.5  
- Mounting clips: 3 C-shaped brackets with width 1.5, height 1`
        };

        // Initialize Three.js viewer
        function initViewer() {
            if (isViewerInitialized) return;

            const viewerContainer = document.getElementById('viewer');
            viewerContainer.innerHTML = '';

            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, viewerContainer.clientWidth / viewerContainer.clientHeight, 0.1, 1000);
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(viewerContainer.clientWidth, viewerContainer.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            viewerContainer.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Grid
            const gridHelper = new THREE.GridHelper(20, 20, 0x888888, 0xcccccc);
            scene.add(gridHelper);

            // Basic mouse controls
            setupMouseControls();

            // Render loop
            function animate() {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            }
            animate();

            isViewerInitialized = true;
        }

        // Simple mouse controls
        function setupMouseControls() {
            let isMouseDown = false;
            let mouseButton = -1;
            let mouseX = 0, mouseY = 0;
            let targetRotation = { x: 0, y: 0 };
            let currentRotation = { x: 0, y: 0 };
            let targetPosition = new THREE.Vector3(5, 5, 5);
            let currentDistance = 10;

            const canvas = renderer.domElement;

            canvas.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                mouseButton = e.button;
                mouseX = e.clientX;
                mouseY = e.clientY;
                e.preventDefault();
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!isMouseDown) return;

                const deltaX = e.clientX - mouseX;
                const deltaY = e.clientY - mouseY;

                if (mouseButton === 0) { // Left button - rotate
                    targetRotation.y += deltaX * 0.01;
                    targetRotation.x += deltaY * 0.01;
                    targetRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, targetRotation.x));
                }

                mouseX = e.clientX;
                mouseY = e.clientY;
            });

            canvas.addEventListener('mouseup', () => {
                isMouseDown = false;
                mouseButton = -1;
            });

            canvas.addEventListener('wheel', (e) => {
                currentDistance += e.deltaY * 0.01;
                currentDistance = Math.max(2, Math.min(50, currentDistance));
                e.preventDefault();
            });

            // Smooth camera animation
            function updateCamera() {
                currentRotation.x += (targetRotation.x - currentRotation.x) * 0.1;
                currentRotation.y += (targetRotation.y - currentRotation.y) * 0.1;

                camera.position.x = Math.cos(currentRotation.y) * Math.cos(currentRotation.x) * currentDistance;
                camera.position.y = Math.sin(currentRotation.x) * currentDistance;
                camera.position.z = Math.sin(currentRotation.y) * Math.cos(currentRotation.x) * currentDistance;
                camera.lookAt(0, 0, 0);

                requestAnimationFrame(updateCamera);
            }
            updateCamera();
        }

        // Natural language parser
        function parseDescription(text) {
            const shapes = [];
            const lines = text.split('\n').filter(line => line.trim());

            for (const line of lines) {
                const shape = parseShapeLine(line.trim());
                if (shape) shapes.push(shape);
            }

            return shapes;
        }

        function parseShapeLine(line) {
            const lowerLine = line.toLowerCase();
            
            // Extract color
            let color = 'gray';
            for (const [colorName, colorValue] of Object.entries(colorMap)) {
                if (lowerLine.includes(colorName)) {
                    color = colorName;
                    break;
                }
            }

            // Extract dimensions
            const widthMatch = lowerLine.match(/width\s*:?\s*(\d+(?:\.\d+)?)/);
            const heightMatch = lowerLine.match(/height\s*:?\s*(\d+(?:\.\d+)?)/);
            const depthMatch = lowerLine.match(/depth\s*:?\s*(\d+(?:\.\d+)?)/);
            const radiusMatch = lowerLine.match(/radius\s*:?\s*(\d+(?:\.\d+)?)/);
            const sizeMatch = lowerLine.match(/size\s*:?\s*(\d+(?:\.\d+)?)/);
            const thicknessMatch = lowerLine.match(/thickness\s*:?\s*(\d+(?:\.\d+)?)/);

            let shape = null;

            // Determine shape type and create object
            if (lowerLine.includes('cube') || lowerLine.includes('box')) {
                const w = widthMatch ? parseFloat(widthMatch[1]) : (sizeMatch ? parseFloat(sizeMatch[1]) : 1);
                const h = heightMatch ? parseFloat(heightMatch[1]) : (sizeMatch ? parseFloat(sizeMatch[1]) : 1);
                const d = depthMatch ? parseFloat(depthMatch[1]) : (sizeMatch ? parseFloat(sizeMatch[1]) : 1);
                
                shape = {
                    type: 'box',
                    width: w,
                    height: h,
                    depth: d,
                    color: color,
                    position: { x: 0, y: 0, z: 0 }
                };
            }
            else if (lowerLine.includes('sphere') || lowerLine.includes('ball')) {
                const r = radiusMatch ? parseFloat(radiusMatch[1]) : 1;
                shape = {
                    type: 'sphere',
                    radius: r,
                    color: color,
                    position: { x: 0, y: 0, z: 0 }
                };
            }
            else if (lowerLine.includes('cylinder')) {
                const r = radiusMatch ? parseFloat(radiusMatch[1]) : 1;
                const h = heightMatch ? parseFloat(heightMatch[1]) : 2;
                shape = {
                    type: 'cylinder',
                    radius: r,
                    height: h,
                    color: color,
                    position: { x: 0, y: 0, z: 0 }
                };
            }
            else if (lowerLine.includes('cone')) {
                const r = radiusMatch ? parseFloat(radiusMatch[1]) : 1;
                const h = heightMatch ? parseFloat(heightMatch[1]) : 2;
                shape = {
                    type: 'cone',
                    radius: r,
                    height: h,
                    color: color,
                    position: { x: 0, y: 0, z: 0 }
                };
            }

            return shape;
        }

        // Generate blueprint from parsed data
        function generateBlueprintFromShapes(shapes) {
            let blueprint = "=== TECHNICAL BLUEPRINT ===\n\n";
            blueprint += `Project: Iron Arm Exoskeleton Component\n`;
            blueprint += `Generated: ${new Date().toLocaleString()}\n`;
            blueprint += `Total Components: ${shapes.length}\n\n`;

            shapes.forEach((shape, index) => {
                blueprint += `--- Component ${index + 1} ---\n`;
                blueprint += `Type: ${shape.type.toUpperCase()}\n`;
                blueprint += `Color: ${shape.color.toUpperCase()}\n`;
                
                if (shape.type === 'box') {
                    blueprint += `Dimensions: ${shape.width} x ${shape.height} x ${shape.depth}\n`;
                    blueprint += `Volume: ${(shape.width * shape.height * shape.depth).toFixed(2)} cubic units\n`;
                } else if (shape.type === 'sphere') {
                    blueprint += `Radius: ${shape.radius}\n`;
                    blueprint += `Volume: ${(4/3 * Math.PI * Math.pow(shape.radius, 3)).toFixed(2)} cubic units\n`;
                } else if (shape.type === 'cylinder') {
                    blueprint += `Radius: ${shape.radius}\n`;
                    blueprint += `Height: ${shape.height}\n`;
                    blueprint += `Volume: ${(Math.PI * Math.pow(shape.radius, 2) * shape.height).toFixed(2)} cubic units\n`;
                } else if (shape.type === 'cone') {
                    blueprint += `Radius: ${shape.radius}\n`;
                    blueprint += `Height: ${shape.height}\n`;
                    blueprint += `Volume: ${(1/3 * Math.PI * Math.pow(shape.radius, 2) * shape.height).toFixed(2)} cubic units\n`;
                }
                
                blueprint += `Position: (${shape.position.x}, ${shape.position.y}, ${shape.position.z})\n\n`;
            });

            blueprint += "=== MANUFACTURING NOTES ===\n";
            blueprint += "‚Ä¢ Recommended print layer height: 0.2mm\n";
            blueprint += "‚Ä¢ Support material: Auto-generate if needed\n";
            blueprint += "‚Ä¢ Infill density: 20% for prototypes, 100% for final parts\n";
            blueprint += "‚Ä¢ Post-processing: Sand support contact areas\n\n";

            blueprint += "=== IRON ARM INTEGRATION ===\n";
            blueprint += "‚Ä¢ Verify dimensions against servo motor specs\n";
            blueprint += "‚Ä¢ Check mounting hole alignment\n";
            blueprint += "‚Ä¢ Confirm cable routing clearances\n";
            blueprint += "‚Ä¢ Test fit with existing components\n";

            return blueprint;
        }

        // Create 3D model from blueprint
        function create3DModelFromShapes(shapes) {
            if (!isViewerInitialized) {
                initViewer();
            }

            // Clear existing model
            if (currentModel) {
                scene.remove(currentModel);
            }

            const group = new THREE.Group();
            let yOffset = 0;

            shapes.forEach((shape, index) => {
                let geometry, material, mesh;

                // Create geometry based on shape type
                switch (shape.type) {
                    case 'box':
                        geometry = new THREE.BoxGeometry(shape.width, shape.height, shape.depth);
                        break;
                    case 'sphere':
                        geometry = new THREE.SphereGeometry(shape.radius, 32, 16);
                        break;
                    case 'cylinder':
                        geometry = new THREE.CylinderGeometry(shape.radius, shape.radius, shape.height, 32);
                        break;
                    case 'cone':
                        geometry = new THREE.ConeGeometry(shape.radius, shape.height, 32);
                        break;
                    default:
                        geometry = new THREE.BoxGeometry(1, 1, 1);
                }

                // Create material with color
                material = new THREE.MeshLambertMaterial({ 
                    color: colorMap[shape.color] || 0x808080,
                    transparent: true,
                    opacity: 0.9
                });

                // Create mesh
                mesh = new THREE.Mesh(geometry, material);
                
                // Position shapes (simple stacking for now)
                mesh.position.set(index * 3, yOffset, 0);
                mesh.castShadow = true;
                mesh.receiveShadow = true;

                // Add wireframe for better visualization
                const wireframe = new THREE.WireframeGeometry(geometry);
                const line = new THREE.LineSegments(wireframe, new THREE.LineBasicMaterial({ 
                    color: 0x000000, 
                    opacity: 0.3,
                    transparent: true 
                }));
                line.position.copy(mesh.position);
                
                group.add(mesh);
                group.add(line);
            });

            scene.add(group);
            currentModel = group;

            // Enable export button
            document.getElementById('exportBtn').disabled = false;
            
            showStatus('3D model created successfully! Use mouse to explore the model.', 'success');
        }

        // Main functions
        function generateBlueprint() {
            const description = document.getElementById('description').value.trim();
            
            if (!description) {
                showStatus('Please enter a description of your 3D object.', 'error');
                return;
            }

            showLoading(true);
            
            setTimeout(() => {
                try {
                    const shapes = parseDescription(description);
                    
                    if (shapes.length === 0) {
                        showStatus('Could not parse any shapes from your description. Try using keywords like "cube", "sphere", "cylinder" with dimensions.', 'error');
                        showLoading(false);
                        return;
                    }

                    const blueprint = generateBlueprintFromShapes(shapes);
                    currentBlueprint = { shapes, blueprint };

                    document.getElementById('blueprintContent').textContent = blueprint;
                    document.getElementById('blueprintSection').style.display = 'block';
                    
                    showStatus(`Blueprint generated successfully! Found ${shapes.length} component(s). Review and click "Create 3D Model" to proceed.`, 'success');
                    showLoading(false);
                } catch (error) {
                    showStatus('Error generating blueprint: ' + error.message, 'error');
                    showLoading(false);
                }
            }, 1000);
        }

        function create3DModel() {
            if (!currentBlueprint) {
                showStatus('No blueprint available. Generate a blueprint first.', 'error');
                return;
            }

            showLoading(true);
            
            setTimeout(() => {
                try {
                    create3DModelFromShapes(currentBlueprint.shapes);
                    showLoading(false);
                } catch (error) {
                    showStatus('Error creating 3D model: ' + error.message, 'error');
                    showLoading(false);
                }
            }, 500);
        }

        function editBlueprint() {
            if (!currentBlueprint) return;
            
            const blueprintContent = document.getElementById('blueprintContent');
            const currentText = blueprintContent.textContent;
            
            blueprintContent.innerHTML = `<textarea style="width: 100%; height: 250px; font-family: 'Courier New', monospace; font-size: 13px; border: 1px solid #ddd; padding: 10px;">${currentText}</textarea>`;
            
            const textarea = blueprintContent.querySelector('textarea');
            textarea.addEventListener('blur', () => {
                blueprintContent.textContent = textarea.value;
            });
        }

        function loadComponent(componentName) {
            const description = ironArmComponents[componentName];
            if (description) {
                document.getElementById('description').value = description;
                showStatus(`Loaded ${componentName} component template. Click "Generate Blueprint" to proceed.`, 'info');
            }
        }

        function loadExample(exampleType) {
            const examples = {
                cube: 'Create a red cube with size 2',
                sphere: 'Make a blue sphere with radius 1.5',
                cylinder: 'Create a green cylinder with radius 1 and height 3',
                complex: 'Create a gray box with width 4, height 2, depth 1. Add a red sphere with radius 0.5 on top.'
            };
            
            const description = examples[exampleType];
            if (description) {
                document.getElementById('description').value = description;
                showStatus('Example loaded! Click "Generate Blueprint" to see the result.', 'info');
            }
        }

        function clearAll() {
            document.getElementById('description').value = '';
            document.getElementById('blueprintSection').style.display = 'none';
            document.getElementById('status').style.display = 'none';
            
            if (currentModel) {
                scene.remove(currentModel);
                currentModel = null;
            }
            
            currentBlueprint = null;
            document.getElementById('exportBtn').disabled = true;
            
            if (isViewerInitialized) {
                const viewerContainer = document.getElementById('viewer');
                viewerContainer.innerHTML = '<div>üé® 3D Viewer Ready<br><small>Generate a blueprint to see your creation</small></div>';
                isViewerInitialized = false;
            }
        }

        function resetView() {
            if (isViewerInitialized && camera) {
                camera.position.set(5, 5, 5);
                camera.lookAt(0, 0, 0);
            }
        }

        function exportSTL() {
            if (!currentModel) {
                showStatus('No 3D model to export. Create a model first.', 'error');
                return;
            }

            try {
                // Simple STL export simulation
                const stlContent = generateSTLContent(currentModel);
                
                const blob = new Blob([stlContent], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `iron_arm_component_${Date.now()}.stl`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                URL.revokeObjectURL(url);
                showStatus('STL file exported successfully!', 'success');
            } catch (error) {
                showStatus('Error exporting STL: ' + error.message, 'error');
            }
        }

        function generateSTLContent(model) {
            // Simplified STL generation (ASCII format)
            let stlString = 'solid IronArmComponent\n';
            
            model.traverse((child) => {
                if (child.isMesh && child.geometry) {
                    const geometry = child.geometry;
                    const positionAttribute = geometry.attributes.position;
                    const indexAttribute = geometry.index;
                    
                    if (positionAttribute && indexAttribute) {
                        const positions = positionAttribute.array;
                        const indices = indexAttribute.array;
                        
                        for (let i = 0; i < indices.length; i += 3) {
                            const a = indices[i] * 3;
                            const b = indices[i + 1] * 3;
                            const c = indices[i + 2] * 3;
                            
                            const v1 = new THREE.Vector3(positions[a], positions[a + 1], positions[a + 2]);
                            const v2 = new THREE.Vector3(positions[b], positions[b + 1], positions[b + 2]);
                            const v3 = new THREE.Vector3(positions[c], positions[c + 1], positions[c + 2]);
                            
                            // Apply world matrix transformations
                            v1.applyMatrix4(child.matrixWorld);
                            v2.applyMatrix4(child.matrixWorld);
                            v3.applyMatrix4(child.matrixWorld);
                            
                            // Calculate normal
                            const normal = new THREE.Vector3()
                                .crossVectors(
                                    new THREE.Vector3().subVectors(v2, v1),
                                    new THREE.Vector3().subVectors(v3, v1)
                                ).normalize();
                            
                            stlString += `  facet normal ${normal.x.toFixed(6)} ${normal.y.toFixed(6)} ${normal.z.toFixed(6)}\n`;
                            stlString += `    outer loop\n`;
                            stlString += `      vertex ${v1.x.toFixed(6)} ${v1.y.toFixed(6)} ${v1.z.toFixed(6)}\n`;
                            stlString += `      vertex ${v2.x.toFixed(6)} ${v2.y.toFixed(6)} ${v2.z.toFixed(6)}\n`;
                            stlString += `      vertex ${v3.x.toFixed(6)} ${v3.y.toFixed(6)} ${v3.z.toFixed(6)}\n`;
                            stlString += `    endloop\n`;
                            stlString += `  endfacet\n`;
                        }
                    }
                }
            });
            
            stlString += 'endsolid IronArmComponent\n';
            return stlString;
        }

        // Utility functions
        function showStatus(message, type) {
            const statusElement = document.getElementById('status');
            statusElement.textContent = message;
            statusElement.className = `status ${type}`;
            statusElement.style.display = 'block';
            
            if (type === 'success' || type === 'info') {
                setTimeout(() => {
                    statusElement.style.display = 'none';
                }, 5000);
            }
        }

        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            if (isViewerInitialized && camera && renderer) {
                const viewerContainer = document.getElementById('viewer');
                const width = viewerContainer.clientWidth;
                const height = viewerContainer.clientHeight;
                
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            }
        });

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            showStatus('üöÄ Text to CAD Generator ready! Start by describing your 3D object or select an Iron Arm component.', 'info');
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'Enter') {
                generateBlueprint();
            }
            if (e.key === 'Escape') {
                clearAll();
            }
        });