<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text to CAD Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            overflow: hidden;
        }
        
        .container {
            display: grid;
            grid-template-columns: 350px 1fr;
            height: 100vh;
        }
        
        .panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            overflow-y: auto;
            box-shadow: 2px 0 20px rgba(0, 0, 0, 0.1);
        }
        
        .viewer {
            background: #1a1a1a;
            position: relative;
        }
        
        h1 {
            margin: 0 0 20px 0;
            color: #333;
            font-size: 24px;
            font-weight: 600;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            color: #555;
            font-weight: 500;
        }
        
        textarea {
            width: 100%;
            height: 100px;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            resize: vertical;
            transition: border-color 0.3s ease;
        }
        
        textarea:focus {
            outline: none;
            border-color: #667eea;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            width: 100%;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .examples {
            margin-top: 30px;
        }
        
        .example {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            border-left: 4px solid #667eea;
        }
        
        .example:hover {
            background: #e9ecef;
        }
        
        .example-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
        }
        
        .example-text {
            color: #666;
            font-size: 12px;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
        }
        
        .control-btn {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            border: none;
            padding: 8px 12px;
            margin-left: 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s ease;
            width: auto;
        }
        
        .control-btn:hover {
            background: white;
            transform: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="panel">
            <h1>ðŸ”§ Text to CAD</h1>
            
            <div class="input-group">
                <label for="textInput">Describe your 3D object:</label>
                <textarea id="textInput" placeholder="e.g., 'Create a blue cube that is 2 units wide' or 'Make a red sphere with radius 1.5'"></textarea>
            </div>
            
            <button onclick="generateCAD()">Generate 3D Model</button>
            
            <div class="examples">
                <h3 style="color: #333; margin-bottom: 15px;">ðŸ’¡ Try these examples:</h3>
                
                <div class="example" onclick="loadExample('Create a blue cube with width 2, height 1.5, and depth 1')">
                    <div class="example-title">Basic Cube</div>
                    <div class="example-text">Create a blue cube with width 2, height 1.5, and depth 1</div>
                </div>
                
                <div class="example" onclick="loadExample('Make a red sphere with radius 1.5')">
                    <div class="example-title">Simple Sphere</div>
                    <div class="example-text">Make a red sphere with radius 1.5</div>
                </div>
                
                <div class="example" onclick="loadExample('Create a green cylinder with radius 0.8 and height 3')">
                    <div class="example-title">Cylinder</div>
                    <div class="example-text">Create a green cylinder with radius 0.8 and height 3</div>
                </div>
                
                <div class="example" onclick="loadExample('Make a yellow torus with inner radius 0.5 and outer radius 1.2')">
                    <div class="example-title">Torus (Donut)</div>
                    <div class="example-text">Make a yellow torus with inner radius 0.5 and outer radius 1.2</div>
                </div>
                
                <div class="example" onclick="loadExample('Create a purple cone with base radius 1 and height 2.5')">
                    <div class="example-title">Cone</div>
                    <div class="example-text">Create a purple cone with base radius 1 and height 2.5</div>
                </div>
                
                <div class="example" onclick="loadExample('Make 3 red cubes arranged in a line with size 1')">
                    <div class="example-title">Multiple Objects</div>
                    <div class="example-text">Make 3 red cubes arranged in a line with size 1</div>
                </div>
            </div>
        </div>
        
        <div class="viewer">
            <div class="controls">
                <button class="control-btn" onclick="resetView()">Reset View</button>
                <button class="control-btn" onclick="exportModel()">Export STL</button>
            </div>
            <div class="info">
                Mouse: Rotate | Wheel: Zoom | Right-click: Pan
            </div>
        </div>
    </div>

    <script>
        let scene, camera, renderer, controls;
        let currentObjects = [];
        
        // Initialize Three.js scene
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2a2a2a);
            
            camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            camera.position.set(5, 5, 5);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            const viewer = document.querySelector('.viewer');
            viewer.appendChild(renderer.domElement);
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Add grid
            const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x444444);
            scene.add(gridHelper);
            
            // Basic mouse controls
            setupControls();
            
            // Handle resize
            window.addEventListener('resize', onWindowResize);
            onWindowResize();
            
            // Start render loop
            animate();
        }
        
        function setupControls() {
            let isRotating = false;
            let isPanning = false;
            let lastMouse = { x: 0, y: 0 };
            
            renderer.domElement.addEventListener('mousedown', (e) => {
                if (e.button === 0) isRotating = true;
                if (e.button === 2) isPanning = true;
                lastMouse = { x: e.clientX, y: e.clientY };
                e.preventDefault();
            });
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                const deltaX = e.clientX - lastMouse.x;
                const deltaY = e.clientY - lastMouse.y;
                
                if (isRotating) {
                    const spherical = new THREE.Spherical();
                    spherical.setFromVector3(camera.position);
                    spherical.theta -= deltaX * 0.01;
                    spherical.phi += deltaY * 0.01;
                    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                    camera.position.setFromSpherical(spherical);
                    camera.lookAt(0, 0, 0);
                }
                
                if (isPanning) {
                    const distance = camera.position.length();
                    const panSpeed = distance * 0.002;
                    camera.position.x -= deltaX * panSpeed;
                    camera.position.y += deltaY * panSpeed;
                }
                
                lastMouse = { x: e.clientX, y: e.clientY };
            });
            
            document.addEventListener('mouseup', () => {
                isRotating = false;
                isPanning = false;
            });
            
            renderer.domElement.addEventListener('wheel', (e) => {
                const distance = camera.position.length();
                const zoomSpeed = distance * 0.1;
                camera.position.multiplyScalar(1 + e.deltaY * 0.001);
                e.preventDefault();
            });
            
            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
        }
        
        function onWindowResize() {
            const viewer = document.querySelector('.viewer');
            const width = viewer.clientWidth;
            const height = viewer.clientHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        // Text parsing and CAD generation
        function parseText(text) {
            const commands = [];
            const sentences = text.toLowerCase().split(/[.!?]+/).filter(s => s.trim());
            
            sentences.forEach(sentence => {
                const words = sentence.trim().split(/\s+/);
                
                // Parse basic shapes
                if (sentence.includes('cube') || sentence.includes('box')) {
                    const cmd = { type: 'cube', color: 'blue', size: [1, 1, 1] };
                    
                    // Extract dimensions
                    const widthMatch = sentence.match(/width\s+(\d+\.?\d*)/);
                    const heightMatch = sentence.match(/height\s+(\d+\.?\d*)/);
                    const depthMatch = sentence.match(/depth\s+(\d+\.?\d*)/);
                    const sizeMatch = sentence.match(/size\s+(\d+\.?\d*)/);
                    
                    if (sizeMatch) {
                        const size = parseFloat(sizeMatch[1]);
                        cmd.size = [size, size, size];
                    } else {
                        if (widthMatch) cmd.size[0] = parseFloat(widthMatch[1]);
                        if (heightMatch) cmd.size[1] = parseFloat(heightMatch[1]);
                        if (depthMatch) cmd.size[2] = parseFloat(depthMatch[1]);
                    }
                    
                    cmd.color = extractColor(sentence) || 'blue';
                    commands.push(cmd);
                }
                
                else if (sentence.includes('sphere') || sentence.includes('ball')) {
                    const cmd = { type: 'sphere', color: 'red', radius: 1 };
                    
                    const radiusMatch = sentence.match(/radius\s+(\d+\.?\d*)/);
                    if (radiusMatch) cmd.radius = parseFloat(radiusMatch[1]);
                    
                    cmd.color = extractColor(sentence) || 'red';
                    commands.push(cmd);
                }
                
                else if (sentence.includes('cylinder')) {
                    const cmd = { type: 'cylinder', color: 'green', radius: 1, height: 2 };
                    
                    const radiusMatch = sentence.match(/radius\s+(\d+\.?\d*)/);
                    const heightMatch = sentence.match(/height\s+(\d+\.?\d*)/);
                    
                    if (radiusMatch) cmd.radius = parseFloat(radiusMatch[1]);
                    if (heightMatch) cmd.height = parseFloat(heightMatch[1]);
                    
                    cmd.color = extractColor(sentence) || 'green';
                    commands.push(cmd);
                }
                
                else if (sentence.includes('torus') || sentence.includes('donut')) {
                    const cmd = { type: 'torus', color: 'yellow', radius: 1, tube: 0.4 };
                    
                    const outerMatch = sentence.match(/outer\s+radius\s+(\d+\.?\d*)/);
                    const innerMatch = sentence.match(/inner\s+radius\s+(\d+\.?\d*)/);
                    const radiusMatch = sentence.match(/radius\s+(\d+\.?\d*)/);
                    
                    if (outerMatch) cmd.radius = parseFloat(outerMatch[1]);
                    if (innerMatch) cmd.tube = parseFloat(innerMatch[1]);
                    if (radiusMatch && !outerMatch) cmd.radius = parseFloat(radiusMatch[1]);
                    
                    cmd.color = extractColor(sentence) || 'yellow';
                    commands.push(cmd);
                }
                
                else if (sentence.includes('cone')) {
                    const cmd = { type: 'cone', color: 'purple', radius: 1, height: 2 };
                    
                    const radiusMatch = sentence.match(/(?:base\s+)?radius\s+(\d+\.?\d*)/);
                    const heightMatch = sentence.match(/height\s+(\d+\.?\d*)/);
                    
                    if (radiusMatch) cmd.radius = parseFloat(radiusMatch[1]);
                    if (heightMatch) cmd.height = parseFloat(heightMatch[1]);
                    
                    cmd.color = extractColor(sentence) || 'purple';
                    commands.push(cmd);
                }
                
                // Handle multiple objects
                const countMatch = sentence.match(/(\d+)\s+/);
                if (countMatch && commands.length > 0) {
                    const count = parseInt(countMatch[1]);
                    const lastCmd = commands[commands.length - 1];
                    lastCmd.count = count;
                }
            });
            
            return commands;
        }
        
        function extractColor(text) {
            const colors = {
                'red': 0xff0000,
                'blue': 0x0066ff,
                'green': 0x00cc00,
                'yellow': 0xffcc00,
                'purple': 0x9900cc,
                'orange': 0xff6600,
                'pink': 0xff66cc,
                'cyan': 0x00cccc,
                'white': 0xffffff,
                'black': 0x333333,
                'gray': 0x808080,
                'grey': 0x808080
            };
            
            for (const [name, hex] of Object.entries(colors)) {
                if (text.includes(name)) return hex;
            }
            return null;
        }
        
        function generateCAD() {
            const text = document.getElementById('textInput').value;
            if (!text.trim()) return;
            
            // Clear existing objects
            currentObjects.forEach(obj => scene.remove(obj));
            currentObjects = [];
            
            const commands = parseText(text);
            
            commands.forEach((cmd, index) => {
                const count = cmd.count || 1;
                
                for (let i = 0; i < count; i++) {
                    let geometry, material, mesh;
                    
                    material = new THREE.MeshLambertMaterial({ 
                        color: cmd.color || 0x0066ff,
                        transparent: true,
                        opacity: 0.9
                    });
                    
                    switch (cmd.type) {
                        case 'cube':
                            geometry = new THREE.BoxGeometry(cmd.size[0], cmd.size[1], cmd.size[2]);
                            break;
                            
                        case 'sphere':
                            geometry = new THREE.SphereGeometry(cmd.radius, 32, 16);
                            break;
                            
                        case 'cylinder':
                            geometry = new THREE.CylinderGeometry(cmd.radius, cmd.radius, cmd.height, 32);
                            break;
                            
                        case 'torus':
                            geometry = new THREE.TorusGeometry(cmd.radius, cmd.tube, 16, 100);
                            break;
                            
                        case 'cone':
                            geometry = new THREE.ConeGeometry(cmd.radius, cmd.height, 32);
                            break;
                            
                        default:
                            continue;
                    }
                    
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    
                    // Position multiple objects
                    if (count > 1) {
                        mesh.position.x = (i - (count - 1) / 2) * 2.5;
                    }
                    
                    // Offset by command index for multiple different objects
                    mesh.position.z = index * 3;
                    
                    scene.add(mesh);
                    currentObjects.push(mesh);
                }
            });
            
            // Auto-fit camera if objects were created
            if (currentObjects.length > 0) {
                fitCameraToObjects();
            }
        }
        
        function fitCameraToObjects() {
            if (currentObjects.length === 0) return;
            
            const box = new THREE.Box3();
            currentObjects.forEach(obj => box.expandByObject(obj));
            
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            
            const maxDim = Math.max(size.x, size.y, size.z);
            const distance = maxDim * 2;
            
            camera.position.set(
                center.x + distance * 0.5,
                center.y + distance * 0.5,
                center.z + distance * 0.5
            );
            camera.lookAt(center);
        }
        
        function loadExample(text) {
            document.getElementById('textInput').value = text;
        }
        
        function resetView() {
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);
        }
        
        function exportModel() {
            if (currentObjects.length === 0) {
                alert('No objects to export! Please generate a model first.');
                return;
            }
            
            // Simple STL export (basic implementation)
            let stlString = 'solid model\n';
            
            currentObjects.forEach(obj => {
                const geometry = obj.geometry;
                const position = geometry.attributes.position;
                const matrix = obj.matrixWorld;
                
                for (let i = 0; i < position.count; i += 3) {
                    const v1 = new THREE.Vector3(
                        position.getX(i),
                        position.getY(i),
                        position.getZ(i)
                    ).applyMatrix4(matrix);
                    
                    const v2 = new THREE.Vector3(
                        position.getX(i + 1),
                        position.getY(i + 1),
                        position.getZ(i + 1)
                    ).applyMatrix4(matrix);
                    
                    const v3 = new THREE.Vector3(
                        position.getX(i + 2),
                        position.getY(i + 2),
                        position.getZ(i + 2)
                    ).applyMatrix4(matrix);
                    
                    const normal = new THREE.Vector3()
                        .subVectors(v2, v1)
                        .cross(new THREE.Vector3().subVectors(v3, v1))
                        .normalize();
                    
                    stlString += `  facet normal ${normal.x} ${normal.y} ${normal.z}\n`;
                    stlString += '    outer loop\n';
                    stlString += `      vertex ${v1.x} ${v1.y} ${v1.z}\n`;
                    stlString += `      vertex ${v2.x} ${v2.y} ${v2.z}\n`;
                    stlString += `      vertex ${v3.x} ${v3.y} ${v3.z}\n`;
                    stlString += '    endloop\n';
                    stlString += '  endfacet\n';
                }
            });
            
            stlString += 'endsolid model\n';
            
            const blob = new Blob([stlString], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'model.stl';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // Initialize when page loads
        window.addEventListener('load', initScene);
    </script>
</body>
</html>